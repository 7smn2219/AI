# -*- coding: utf-8 -*-
"""ai9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14QGc9JKY-sFRQaSFNv0Gj5gGqBKGhxBC

Artificial Intelligence
---
**Practical 9** Hill Climbing Heuristic Search Techniques
"""

from numpy import asarray
from numpy import arange
from numpy.random import randn
from numpy.random import rand
from numpy.random import seed
from matplotlib import pyplot

def objective(x):
	return x[0]**2.0

def hillclimbing(objective, bounds, n_iterations, step_size):
	solution = bounds[:, 0] + rand(len(bounds)) * (bounds[:, 1] - bounds[:, 0])
	solution_eval = objective(solution)
	solutions = list()
	solutions.append(solution)
	for i in range(n_iterations):
		candidate = solution + randn(len(bounds)) * step_size
		candidte_eval = objective(candidate)

		if candidte_eval <= solution_eval:
			solution, solution_eval = candidate, candidte_eval
			solutions.append(solution)
			print('>%d f(%s) = %.5f' % (i, solution, solution_eval))
	return [solution, solution_eval, solutions]

seed(5)
bounds = asarray([[-5.0, 5.0]])
n_iterations = 100

step_size = 0.1
best, score, solutions = hillclimbing(objective, bounds, n_iterations, step_size)
print('Done!')
print('f(%s) = %f' % (best, score))

# sample input range uniformly at 0.1 increments
inputs = arange(bounds[0,0], bounds[0,1], 0.1)
# create a line plot of input vs result
pyplot.plot(inputs, [objective([x]) for x in inputs], '--')
# draw a vertical line at the optimal input
pyplot.axvline(x=[0.0], ls='--', color='red')
# plot the sample as black circles
pyplot.plot(solutions, [objective(x) for x in solutions], 'o', color='black')
pyplot.show()